{"version":3,"file":"plugin.js","sources":["esm/installMode.js","esm/fileUtil.js","esm/nativeAppInfo.js","esm/sdk.js","esm/localPackage.js","esm/remotePackage.js","esm/syncStatus.js","esm/codePush.js"],"sourcesContent":["/**\n * Defines the available install modes for updates.\n */\nvar InstallMode;\n(function (InstallMode) {\n    /**\n     * The update will be applied to the running application immediately. The application will be reloaded with the new content immediately.\n     */\n    InstallMode[InstallMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n    /**\n     * The update is downloaded but not installed immediately. The new content will be available the next time the application is started.\n     */\n    InstallMode[InstallMode[\"ON_NEXT_RESTART\"] = 1] = \"ON_NEXT_RESTART\";\n    /**\n     * The udpate is downloaded but not installed immediately. The new content will be available the next time the application is resumed or restarted, whichever event happends first.\n     */\n    InstallMode[InstallMode[\"ON_NEXT_RESUME\"] = 2] = \"ON_NEXT_RESUME\";\n})(InstallMode || (InstallMode = {}));\nexport default InstallMode;\n//# sourceMappingURL=installMode.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Directory, Filesystem, Encoding } from '@capacitor/filesystem';\n/**\n * File utilities for CodePush.\n */\nexport class FileUtil {\n    static directoryExists(directory, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const statResult = yield Filesystem.stat({ directory, path });\n                return statResult.type === \"directory\";\n            }\n            catch (error) {\n                return false;\n            }\n        });\n    }\n    static writeStringToDataFile(content, path, createIfNotExists, callback) {\n        FileUtil.writeStringToFile(content, Directory.Data, path, createIfNotExists, callback);\n    }\n    static fileExists(directory, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const statResult = yield Filesystem.stat({ directory, path });\n                return statResult.type === \"file\";\n            }\n            catch (error) {\n                return false;\n            }\n        });\n    }\n    /**\n     * Makes sure the given directory exists and is empty.\n     */\n    static cleanDataDirectory(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield FileUtil.dataDirectoryExists(path)) {\n                yield FileUtil.deleteDataDirectory(path);\n            }\n            yield Filesystem.mkdir({ directory: Directory.Data, path, recursive: true });\n            const appDir = yield Filesystem.getUri({ directory: Directory.Data, path });\n            return appDir.uri;\n        });\n    }\n    static getUri(fsDir, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield Filesystem.getUri({ directory: fsDir, path });\n            return result.uri;\n        });\n    }\n    static getDataUri(path) {\n        return FileUtil.getUri(Directory.Data, path);\n    }\n    static dataDirectoryExists(path) {\n        return FileUtil.directoryExists(Directory.Data, path);\n    }\n    static copyDirectoryEntriesTo(sourceDir, destinationDir, ignoreList = []) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /*\n                Native-side exception occurs while trying to copy “.DS_Store” and “__MACOSX” entries generated by macOS, so just skip them\n            */\n            if (ignoreList.indexOf(\".DS_Store\") === -1) {\n                ignoreList.push(\".DS_Store\");\n            }\n            if (ignoreList.indexOf(\"__MACOSX\") === -1) {\n                ignoreList.push(\"__MACOSX\");\n            }\n            return FileUtil.copy(sourceDir, destinationDir);\n        });\n    }\n    static copy(source, destination) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield Filesystem.copy({ directory: source.directory, from: source.path, to: destination.path, toDirectory: destination.directory });\n        });\n    }\n    /**\n     * Recursively deletes the contents of a directory.\n     */\n    static deleteDataDirectory(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Filesystem.rmdir({ directory: Directory.Data, path, recursive: true }).then(() => null);\n        });\n    }\n    /**\n     * Deletes a given set of files from a directory.\n     */\n    static deleteEntriesFromDataDirectory(dirPath, filesToDelete) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const file of filesToDelete) {\n                const path = dirPath + \"/\" + file;\n                const fileExists = yield FileUtil.fileExists(Directory.Data, path);\n                if (!fileExists)\n                    continue;\n                try {\n                    yield Filesystem.deleteFile({ directory: Directory.Data, path });\n                }\n                catch (error) {\n                    /* If delete fails, silently continue */\n                    console.log(\"Could not delete file: \" + path);\n                }\n            }\n        });\n    }\n    /**\n     * Writes a string to a file.\n     */\n    static writeStringToFile(data, directory, path, createIfNotExists, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield Filesystem.writeFile({ directory, path, data, encoding: Encoding.UTF8 });\n                callback(null, null);\n            }\n            catch (error) {\n                callback(new Error(\"Could write the current package information file. Error code: \" + error.code), null);\n            }\n        });\n    }\n    static readFile(directory, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield Filesystem.readFile({ directory, path, encoding: Encoding.UTF8 });\n            return result.data;\n        });\n    }\n    static readDataFile(path) {\n        return FileUtil.readFile(Directory.Data, path);\n    }\n}\n//# sourceMappingURL=fileUtil.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Plugins } from \"@capacitor/core\";\nconst NativeCodePush = Plugins.CodePush;\nconst DefaultServerUrl = \"https://codepush.appcenter.ms/\";\n/**\n * Provides information about the native app.\n */\nexport class NativeAppInfo {\n    /**\n     * Gets the application build timestamp.\n     */\n    static getApplicationBuildTime() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.getNativeBuildTime();\n                return result.value;\n            }\n            catch (e) {\n                throw new Error(\"Could not get application timestamp.\");\n            }\n        });\n    }\n    /**\n     * Gets the application version.\n     */\n    static getApplicationVersion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.getAppVersion();\n                return result.value;\n            }\n            catch (e) {\n                throw new Error(\"Could not get application version.\");\n            }\n        });\n    }\n    /**\n     * Gets a hash of the `www` folder contents compiled in the app store binary.\n     */\n    static getBinaryHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.getBinaryHash();\n                return result.value;\n            }\n            catch (e) {\n                throw new Error(\"Could not get binary hash.\");\n            }\n        });\n    }\n    /**\n     * Gets the server URL from config.xml by calling into the native platform.\n     */\n    static getServerURL() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.getServerURL();\n                return result.value;\n            }\n            catch (e) {\n                return DefaultServerUrl;\n            }\n        });\n    }\n    /**\n     * Gets the deployment key from config.xml by calling into the native platform.\n     */\n    static getDeploymentKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.getDeploymentKey();\n                return result.value;\n            }\n            catch (e) {\n                throw new Error(\"Deployment key not found.\");\n            }\n        });\n    }\n    /**\n     * Checks if a package update was previously attempted but failed for a given package hash.\n     * Every reverted update is stored such that the application developer has the option to ignore\n     * updates that previously failed. This way, an infinite update loop can be prevented in case of a bad update package.\n     */\n    static isFailedUpdate(packageHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.isFailedUpdate({ packageHash });\n                return result.value;\n            }\n            catch (e) {\n                /* In case of an error, return false. */\n                return false;\n            }\n        });\n    }\n    /**\n     * Checks if this is the first application run of a package after it has been applied.\n     * The didUpdateCallback callback can be used for migrating data from the old app version to the new one.\n     *\n     * @param packageHash The hash value of the package.\n     * @returns Whether it is the first run after an update.\n     */\n    static isFirstRun(packageHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.isFirstRun({ packageHash });\n                return result.value;\n            }\n            catch (e) {\n                /* In case of an error, return false. */\n                return false;\n            }\n        });\n    }\n    /**\n     * Checks with the native side if there is a pending update.\n     */\n    static isPendingUpdate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield NativeCodePush.isPendingUpdate();\n                return result.value;\n            }\n            catch (e) {\n                /* In case of an error, return false. */\n                return false;\n            }\n        });\n    }\n}\n//# sourceMappingURL=nativeAppInfo.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AcquisitionManager } from \"code-push/script/acquisition-sdk\";\nimport { HttpRequester } from \"./httpRequester\";\nimport { NativeAppInfo } from \"./nativeAppInfo\";\nimport { Device } from '@capacitor/device';\n/**\n * Interacts with the CodePush Acquisition SDK.\n */\nexport class Sdk {\n    /**\n     * Reads the CodePush configuration and creates an AcquisitionManager instance using it.\n     */\n    static getAcquisitionManager(userDeploymentKey, contentType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const resolveManager = () => {\n                if (userDeploymentKey !== Sdk.DefaultConfiguration.deploymentKey || contentType) {\n                    var customConfiguration = {\n                        deploymentKey: userDeploymentKey || Sdk.DefaultConfiguration.deploymentKey,\n                        serverUrl: Sdk.DefaultConfiguration.serverUrl,\n                        ignoreAppVersion: Sdk.DefaultConfiguration.ignoreAppVersion,\n                        appVersion: Sdk.DefaultConfiguration.appVersion,\n                        clientUniqueId: Sdk.DefaultConfiguration.clientUniqueId\n                    };\n                    var requester = new HttpRequester(contentType);\n                    var customAcquisitionManager = new AcquisitionManager(requester, customConfiguration);\n                    return Promise.resolve(customAcquisitionManager);\n                }\n                else if (Sdk.DefaultConfiguration.deploymentKey) {\n                    return Promise.resolve(Sdk.DefaultAcquisitionManager);\n                }\n                else {\n                    return Promise.reject(new Error(\"No deployment key provided, please provide a default one in your config.xml or specify one in the call to checkForUpdate() or sync().\"));\n                }\n            };\n            if (Sdk.DefaultAcquisitionManager) {\n                return resolveManager();\n            }\n            else {\n                let serverUrl = null;\n                try {\n                    serverUrl = yield NativeAppInfo.getServerURL();\n                }\n                catch (e) {\n                    throw new Error(\"Could not get the CodePush configuration. Please check your config.xml file.\");\n                }\n                let appVersion = null;\n                try {\n                    appVersion = yield NativeAppInfo.getApplicationVersion();\n                }\n                catch (e) {\n                    throw new Error(\"Could not get the app version. Please check your config.xml file.\");\n                }\n                let deploymentKey = null;\n                try {\n                    deploymentKey = yield NativeAppInfo.getDeploymentKey();\n                }\n                catch (e) { }\n                const device = yield Device.getInfo();\n                Sdk.DefaultConfiguration = {\n                    deploymentKey,\n                    serverUrl,\n                    ignoreAppVersion: false,\n                    appVersion,\n                    clientUniqueId: device.uuid\n                };\n                if (deploymentKey) {\n                    Sdk.DefaultAcquisitionManager = new AcquisitionManager(new HttpRequester(), Sdk.DefaultConfiguration);\n                }\n                return resolveManager();\n            }\n        });\n    }\n    /**\n     * Reports the deployment status to the CodePush server.\n     */\n    static reportStatusDeploy(pkg, status, currentDeploymentKey, previousLabelOrAppVersion, previousDeploymentKey, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const acquisitionManager = yield Sdk.getAcquisitionManager(currentDeploymentKey, \"application/json\");\n                acquisitionManager.reportStatusDeploy(pkg, status, previousLabelOrAppVersion, previousDeploymentKey, callback);\n            }\n            catch (e) {\n                callback && callback(e);\n            }\n        });\n    }\n    /**\n     * Reports the download status to the CodePush server.\n     */\n    static reportStatusDownload(pkg, deploymentKey, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const acquisitionManager = yield Sdk.getAcquisitionManager(deploymentKey, \"application/json\");\n                acquisitionManager.reportStatusDownload(pkg, callback);\n            }\n            catch (e) {\n                callback && callback(new Error(\"An error occured while reporting the download status. \" + e));\n            }\n        });\n    }\n}\n//# sourceMappingURL=sdk.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Plugins } from \"@capacitor/core\";\nimport { Directory, Filesystem } from '@capacitor/filesystem';\nimport { AcquisitionStatus } from \"code-push/script/acquisition-sdk\";\nimport { CodePushUtil } from \"./codePushUtil\";\nimport { FileUtil } from \"./fileUtil\";\nimport InstallMode from \"./installMode\";\nimport { NativeAppInfo } from \"./nativeAppInfo\";\nimport { Package } from \"./package\";\nimport { Sdk } from \"./sdk\";\nconst NativeCodePush = Plugins.CodePush;\n/**\n * Defines a local package.\n *\n * !! THIS TYPE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\nexport class LocalPackage extends Package {\n    /**\n     * Applies this package to the application. The application will be reloaded with this package and on every application launch this package will be loaded.\n     * On the first run after the update, the application will wait for a codePush.notifyApplicationReady() call. Once this call is made, the install operation is considered a success.\n     * Otherwise, the install operation will be marked as failed, and the application is reverted to its previous version on the next run.\n     *\n     * @param installOptions Optional parameter used for customizing the installation behavior.\n     */\n    install(installOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    CodePushUtil.logMessage(\"Installing update\");\n                    if (!installOptions) {\n                        installOptions = LocalPackage.getDefaultInstallOptions();\n                    }\n                    else {\n                        CodePushUtil.copyUnassignedMembers(LocalPackage.getDefaultInstallOptions(), installOptions);\n                    }\n                    var installError = (error) => {\n                        CodePushUtil.invokeErrorCallback(error, reject);\n                        Sdk.reportStatusDeploy(this, AcquisitionStatus.DeploymentFailed, this.deploymentKey);\n                    };\n                    let unzipDir;\n                    try {\n                        unzipDir = yield FileUtil.cleanDataDirectory(LocalPackage.DownloadUnzipDir);\n                    }\n                    catch (error) {\n                        installError(error);\n                        return;\n                    }\n                    try {\n                        yield NativeCodePush.unzip({ zipFile: this.localPath, targetDirectory: unzipDir });\n                    }\n                    catch (unzipError) {\n                        installError(new Error(\"Could not unzip package\" + CodePushUtil.getErrorMessage(unzipError)));\n                        return;\n                    }\n                    try {\n                        const newPackageLocation = LocalPackage.VersionsDir + \"/\" + this.packageHash;\n                        const deploymentResult = yield LocalPackage.handleDeployment(newPackageLocation);\n                        yield this.verifyPackage(deploymentResult);\n                        this.localPath = deploymentResult.deployDir;\n                        this.finishInstall(deploymentResult.deployDir, installOptions, resolve, installError);\n                    }\n                    catch (error) {\n                        installError(error);\n                    }\n                }\n                catch (e) {\n                    installError && installError(new Error(\"An error occured while installing the package. \" + CodePushUtil.getErrorMessage(e)));\n                }\n            }));\n        });\n    }\n    verifyPackage(deploymentResult) {\n        return new Promise((resolve, reject) => {\n            var deployDir = deploymentResult.deployDir;\n            var verificationFail = (error) => {\n                reject(error);\n            };\n            var verify = (isSignatureVerificationEnabled, isSignatureAppearedInBundle, publicKey, signature) => {\n                if (isSignatureVerificationEnabled) {\n                    if (isSignatureAppearedInBundle) {\n                        this.verifyHash(deployDir, this.packageHash, verificationFail, () => {\n                            this.verifySignature(deployDir, this.packageHash, publicKey, signature, verificationFail, resolve);\n                        });\n                    }\n                    else {\n                        var errorMessage = \"Error! Public key was provided but there is no JWT signature within app bundle to verify. \" +\n                            \"Possible reasons, why that might happen: \\n\" +\n                            \"1. You've been released CodePush bundle update using version of CodePush CLI that is not support code signing.\\n\" +\n                            \"2. You've been released CodePush bundle update without providing --privateKeyPath option.\";\n                        reject(new Error(errorMessage));\n                    }\n                }\n                else {\n                    if (isSignatureAppearedInBundle) {\n                        CodePushUtil.logMessage(\"Warning! JWT signature exists in codepush update but code integrity check couldn't be performed because there is no public key configured. \" +\n                            \"Please ensure that public key is properly configured within your application.\");\n                        // verifyHash\n                        this.verifyHash(deployDir, this.packageHash, verificationFail, resolve);\n                    }\n                    else {\n                        if (deploymentResult.isDiffUpdate) {\n                            // verifyHash\n                            this.verifyHash(deployDir, this.packageHash, verificationFail, resolve);\n                        }\n                        else {\n                            resolve();\n                        }\n                    }\n                }\n            };\n            if (deploymentResult.isDiffUpdate) {\n                CodePushUtil.logMessage(\"Applying diff update\");\n            }\n            else {\n                CodePushUtil.logMessage(\"Applying full update\");\n            }\n            var isSignatureVerificationEnabled, isSignatureAppearedInBundle;\n            var publicKey;\n            this.getPublicKey((error, publicKeyResult) => {\n                if (error) {\n                    reject(new Error(\"Error reading public key. \" + error));\n                    return;\n                }\n                publicKey = publicKeyResult;\n                isSignatureVerificationEnabled = !!publicKey;\n                this.getSignatureFromUpdate(deploymentResult.deployDir, (error, signature) => {\n                    if (error) {\n                        reject(new Error(\"Error reading signature from update. \" + error));\n                        return;\n                    }\n                    isSignatureAppearedInBundle = !!signature;\n                    verify(isSignatureVerificationEnabled, isSignatureAppearedInBundle, publicKey, signature);\n                });\n            });\n        });\n    }\n    getPublicKey(callback) {\n        var success = (publicKey) => {\n            callback(null, publicKey);\n        };\n        var fail = (error) => {\n            callback(error, null);\n        };\n        NativeCodePush.getPublicKey().then(result => success(result.value || null), fail);\n    }\n    getSignatureFromUpdate(deployDir, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const filePath = deployDir + \"/www/.codepushrelease\";\n            if (!(yield FileUtil.fileExists(Directory.Data, filePath))) {\n                // signature absents in the bundle\n                callback(null, null);\n                return;\n            }\n            try {\n                const signature = yield FileUtil.readFile(Directory.Data, filePath);\n                callback(null, signature);\n            }\n            catch (error) {\n                // error reading signature file from bundle\n                callback(error, null);\n            }\n        });\n    }\n    verifyHash(deployDir, newUpdateHash, errorCallback, successCallback) {\n        var packageHashSuccess = (computedHash) => {\n            if (computedHash !== newUpdateHash) {\n                errorCallback(new Error(\"The update contents failed the data integrity check.\"));\n                return;\n            }\n            CodePushUtil.logMessage(\"The update contents succeeded the data integrity check.\");\n            successCallback();\n        };\n        var packageHashFail = (error) => {\n            errorCallback(new Error(\"Unable to compute hash for package: \" + error));\n        };\n        CodePushUtil.logMessage(\"Verifying hash for folder path: \" + deployDir);\n        NativeCodePush.getPackageHash({ path: deployDir }).then(result => packageHashSuccess(result.value), packageHashFail);\n    }\n    verifySignature(deployDir, newUpdateHash, publicKey, signature, errorCallback, successCallback) {\n        var decodeSignatureSuccess = (contentHash) => {\n            if (contentHash !== newUpdateHash) {\n                errorCallback(new Error(\"The update contents failed the code signing check.\"));\n                return;\n            }\n            CodePushUtil.logMessage(\"The update contents succeeded the code signing check.\");\n            successCallback();\n        };\n        var decodeSignatureFail = (error) => {\n            errorCallback(new Error(\"Unable to verify signature for package: \" + error));\n        };\n        CodePushUtil.logMessage(\"Verifying signature for folder path: \" + deployDir);\n        NativeCodePush.decodeSignature({ publicKey, signature }).then(result => decodeSignatureSuccess(result.value), decodeSignatureFail);\n    }\n    finishInstall(deployDir, installOptions, installSuccess, installError) {\n        function backupPackageInformationFileIfNeeded(backupIfNeededDone) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const pendingUpdate = yield NativeAppInfo.isPendingUpdate();\n                if (pendingUpdate) {\n                    // Don't back up the  currently installed update since it hasn't been \"confirmed\"\n                    backupIfNeededDone(null, null);\n                }\n                else {\n                    try {\n                        yield LocalPackage.backupPackageInformationFile();\n                        backupIfNeededDone(null, null);\n                    }\n                    catch (err) {\n                        backupIfNeededDone(err, null);\n                    }\n                }\n            });\n        }\n        LocalPackage.getCurrentOrDefaultPackage().then((oldPackage) => {\n            backupPackageInformationFileIfNeeded((backupError) => {\n                /* continue on error, current package information is missing if this is the first update */\n                this.writeNewPackageMetadata().then(() => {\n                    var invokeSuccessAndInstall = () => {\n                        CodePushUtil.logMessage(\"Install succeeded.\");\n                        var installModeToUse = this.isMandatory ? installOptions.mandatoryInstallMode : installOptions.installMode;\n                        if (installModeToUse === InstallMode.IMMEDIATE) {\n                            /* invoke success before navigating */\n                            installSuccess && installSuccess(installModeToUse);\n                            /* no need for callbacks, the javascript context will reload */\n                            NativeCodePush.install({\n                                startLocation: deployDir,\n                                installMode: installModeToUse,\n                                minimumBackgroundDuration: installOptions.minimumBackgroundDuration\n                            });\n                        }\n                        else {\n                            NativeCodePush.install({\n                                startLocation: deployDir,\n                                installMode: installModeToUse,\n                                minimumBackgroundDuration: installOptions.minimumBackgroundDuration\n                            }).then(() => { installSuccess && installSuccess(installModeToUse); }, () => { installError && installError(); });\n                        }\n                    };\n                    var preInstallSuccess = () => {\n                        /* package will be cleaned up after success, on the native side */\n                        invokeSuccessAndInstall();\n                    };\n                    var preInstallFailure = (preInstallError) => {\n                        CodePushUtil.logError(\"Preinstall failure.\", preInstallError);\n                        var error = new Error(\"An error has occured while installing the package. \" + CodePushUtil.getErrorMessage(preInstallError));\n                        installError && installError(error);\n                    };\n                    NativeCodePush.preInstall({ startLocation: deployDir }).then(preInstallSuccess, preInstallFailure);\n                }, (writeMetadataError) => {\n                    installError && installError(writeMetadataError);\n                });\n            });\n        }, installError);\n    }\n    static handleDeployment(newPackageLocation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const manifestFile = {\n                directory: Directory.Data,\n                path: LocalPackage.DownloadUnzipDir + \"/\" + LocalPackage.DiffManifestFile\n            };\n            const isDiffUpdate = yield FileUtil.fileExists(manifestFile.directory, manifestFile.path);\n            yield Filesystem.mkdir({ path: LocalPackage.VersionsDir, directory: Directory.Data, recursive: true });\n            (yield isDiffUpdate)\n                ? LocalPackage.handleDiffDeployment(newPackageLocation, manifestFile)\n                : LocalPackage.handleCleanDeployment(newPackageLocation);\n            return { deployDir: newPackageLocation, isDiffUpdate };\n        });\n    }\n    writeNewPackageMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timestamp = yield NativeAppInfo.getApplicationBuildTime().catch(buildTimeError => {\n                CodePushUtil.logError(\"Could not get application build time. \" + buildTimeError);\n            });\n            const appVersion = yield NativeAppInfo.getApplicationVersion().catch(appVersionError => {\n                CodePushUtil.logError(\"Could not get application version.\" + appVersionError);\n            });\n            const currentPackageMetadata = {\n                nativeBuildTime: timestamp,\n                localPath: this.localPath,\n                appVersion: appVersion,\n                deploymentKey: this.deploymentKey,\n                description: this.description,\n                isMandatory: this.isMandatory,\n                packageSize: this.packageSize,\n                label: this.label,\n                packageHash: this.packageHash,\n                isFirstRun: false,\n                failedInstall: false,\n                install: undefined\n            };\n            return new Promise((resolve, reject) => {\n                LocalPackage.writeCurrentPackageInformation(currentPackageMetadata, error => error ? reject(error) : resolve());\n            });\n        });\n    }\n    static handleCleanDeployment(newPackageLocation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // no diff manifest\n            const source = { directory: Directory.Data, path: LocalPackage.DownloadUnzipDir };\n            const target = { directory: Directory.Data, path: newPackageLocation };\n            // TODO: create destination directory if it doesn't exist\n            return FileUtil.copyDirectoryEntriesTo(source, target);\n        });\n    }\n    static copyCurrentPackage(newPackageLocation, ignoreList) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentPackagePath = yield new Promise(resolve => {\n                LocalPackage.getPackage(LocalPackage.PackageInfoFile, (currentPackage) => resolve(currentPackage.localPath), () => resolve());\n            });\n            newPackageLocation = currentPackagePath ? newPackageLocation : newPackageLocation + \"/www\";\n            // https://github.com/ionic-team/capacitor/pull/2514 Directory.Application variable was removed. (TODO - for check)\n            const source = currentPackagePath ? { directory: Directory.Data, path: currentPackagePath } : { directory: Directory.Data, path: \"www\" };\n            const target = { directory: Directory.Data, path: newPackageLocation };\n            return FileUtil.copyDirectoryEntriesTo(source, target, ignoreList);\n        });\n    }\n    static handleDiffDeployment(newPackageLocation, diffManifest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let manifest;\n            try {\n                yield LocalPackage.copyCurrentPackage(newPackageLocation, [\".codepushrelease\"]);\n                yield LocalPackage.handleCleanDeployment(newPackageLocation);\n                /* delete files mentioned in the manifest */\n                const content = yield FileUtil.readFile(diffManifest.directory, diffManifest.path);\n                manifest = JSON.parse(content);\n                yield FileUtil.deleteEntriesFromDataDirectory(newPackageLocation, manifest.deletedFiles);\n            }\n            catch (error) {\n                throw new Error(\"Cannot perform diff-update.\");\n            }\n        });\n    }\n    /**\n    * Writes the given local package information to the current package information file.\n    * @param packageInfoMetadata The object to serialize.\n    * @param callback In case of an error, this function will be called with the error as the fist parameter.\n    */\n    static writeCurrentPackageInformation(packageInfoMetadata, callback) {\n        var content = JSON.stringify(packageInfoMetadata);\n        FileUtil.writeStringToDataFile(content, LocalPackage.RootDir + \"/\" + LocalPackage.PackageInfoFile, true, callback);\n    }\n    /**\n     * Backs up the current package information to the old package information file.\n     * This file is used for recovery in case of an update going wrong.\n     * @param callback In case of an error, this function will be called with the error as the fist parameter.\n     */\n    static backupPackageInformationFile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const source = {\n                directory: Directory.Data,\n                path: LocalPackage.RootDir + \"/\" + LocalPackage.PackageInfoFile\n            };\n            const destination = {\n                directory: Directory.Data,\n                path: LocalPackage.RootDir + \"/\" + LocalPackage.OldPackageInfoFile\n            };\n            return FileUtil.copy(source, destination);\n        });\n    }\n    /**\n     * Get the previous package information.\n     *\n     * @param packageSuccess Callback invoked with the old package information.\n     * @param packageError Optional callback invoked in case of an error.\n     */\n    static getOldPackage(packageSuccess, packageError) {\n        LocalPackage.getPackage(LocalPackage.OldPackageInfoFile, packageSuccess, packageError);\n    }\n    /**\n     * Reads package information from a given file.\n     *\n     * @param packageFile The package file name.\n     * @param packageSuccess Callback invoked with the package information.\n     * @param packageError Optional callback invoked in case of an error.\n     */\n    static getPackage(packageFile, packageSuccess, packageError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var handleError = (e) => {\n                packageError && packageError(new Error(\"Cannot read package information. \" + CodePushUtil.getErrorMessage(e)));\n            };\n            try {\n                const content = yield FileUtil.readDataFile(LocalPackage.RootDir + \"/\" + packageFile);\n                const packageInfo = JSON.parse(content);\n                LocalPackage.getLocalPackageFromMetadata(packageInfo).then(packageSuccess, packageError);\n            }\n            catch (e) {\n                handleError(e);\n            }\n        });\n    }\n    static getLocalPackageFromMetadata(metadata) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!metadata) {\n                throw new Error(\"Invalid package metadata.\");\n            }\n            const installFailed = yield NativeAppInfo.isFailedUpdate(metadata.packageHash);\n            const isFirstRun = yield NativeAppInfo.isFirstRun(metadata.packageHash);\n            const localPackage = new LocalPackage();\n            localPackage.appVersion = metadata.appVersion;\n            localPackage.deploymentKey = metadata.deploymentKey;\n            localPackage.description = metadata.description;\n            localPackage.isMandatory = metadata.isMandatory;\n            localPackage.failedInstall = installFailed;\n            localPackage.isFirstRun = isFirstRun;\n            localPackage.label = metadata.label;\n            localPackage.localPath = metadata.localPath;\n            localPackage.packageHash = metadata.packageHash;\n            localPackage.packageSize = metadata.packageSize;\n            return localPackage;\n        });\n    }\n    static getCurrentOrDefaultPackage() {\n        return LocalPackage.getPackageInfoOrDefault(LocalPackage.PackageInfoFile);\n    }\n    static getOldOrDefaultPackage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return LocalPackage.getPackageInfoOrDefault(LocalPackage.OldPackageInfoFile);\n        });\n    }\n    static getPackageInfoOrDefault(packageFile) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const packageFailure = () => __awaiter(this, void 0, void 0, function* () {\n                    /**\n                     * For the default package we need the app version,\n                     * and ideally the hash of the binary contents.\n                     */\n                    let appVersion;\n                    try {\n                        appVersion = yield NativeAppInfo.getApplicationVersion();\n                    }\n                    catch (appVersionError) {\n                        CodePushUtil.logError(\"Could not get application version.\" + appVersionError);\n                        reject(appVersionError);\n                        return;\n                    }\n                    const defaultPackage = new LocalPackage();\n                    defaultPackage.appVersion = appVersion;\n                    try {\n                        defaultPackage.packageHash = yield NativeAppInfo.getBinaryHash();\n                    }\n                    catch (binaryHashError) {\n                        CodePushUtil.logError(\"Could not get binary hash.\" + binaryHashError);\n                    }\n                    resolve(defaultPackage);\n                });\n                LocalPackage.getPackage(packageFile, resolve, packageFailure);\n            });\n        });\n    }\n    static getPackageInfoOrNull(packageFile, packageSuccess, packageError) {\n        LocalPackage.getPackage(packageFile, packageSuccess, packageSuccess.bind(null, null));\n    }\n    /**\n     * Returns the default options for the CodePush install operation.\n     * If the options are not defined yet, the static DefaultInstallOptions member will be instantiated.\n     */\n    static getDefaultInstallOptions() {\n        if (!LocalPackage.DefaultInstallOptions) {\n            LocalPackage.DefaultInstallOptions = {\n                installMode: InstallMode.ON_NEXT_RESTART,\n                minimumBackgroundDuration: 0,\n                mandatoryInstallMode: InstallMode.IMMEDIATE\n            };\n        }\n        return LocalPackage.DefaultInstallOptions;\n    }\n}\nLocalPackage.RootDir = \"codepush\";\nLocalPackage.DownloadDir = LocalPackage.RootDir + \"/download\";\nLocalPackage.DownloadUnzipDir = LocalPackage.DownloadDir + \"/unzipped\";\nLocalPackage.DeployDir = LocalPackage.RootDir + \"/deploy\";\nLocalPackage.VersionsDir = LocalPackage.DeployDir + \"/versions\";\nLocalPackage.PackageUpdateFileName = \"update.zip\";\nLocalPackage.PackageInfoFile = \"currentPackage.json\";\nLocalPackage.OldPackageInfoFile = \"oldPackage.json\";\nLocalPackage.DiffManifestFile = \"hotcodepush.json\";\n//# sourceMappingURL=localPackage.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Plugins } from \"@capacitor/core\";\nimport { CodePushUtil } from \"./codePushUtil\";\nimport { LocalPackage } from \"./localPackage\";\nimport { NativeAppInfo } from \"./nativeAppInfo\";\nimport { Package } from \"./package\";\nimport { Sdk } from \"./sdk\";\nimport { Directory, Filesystem } from \"@capacitor/filesystem\";\nconst { FileTransfer } = Plugins;\n/**\n * Defines a remote package, which represents an update package available for download.\n */\nexport class RemotePackage extends Package {\n    constructor() {\n        super(...arguments);\n        this.isDownloading = false;\n    }\n    /**\n     * Downloads the package update from the CodePush service.\n     * TODO: implement download progress\n     *\n     * @param downloadProgress Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n     */\n    download(downloadProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            CodePushUtil.logMessage(\"Downloading update\");\n            if (!this.downloadUrl) {\n                CodePushUtil.throwError(new Error(\"The remote package does not contain a download URL.\"));\n            }\n            this.isDownloading = true;\n            const dataDirectory = yield Filesystem.getUri({ directory: Directory.Data, path: \"\" });\n            const file = dataDirectory.uri + \"/\" + LocalPackage.DownloadDir + \"/\" + LocalPackage.PackageUpdateFileName;\n            try {\n                yield FileTransfer.download({ source: this.downloadUrl, target: file });\n            }\n            catch (e) {\n                CodePushUtil.throwError(new Error(\"An error occured while downloading the package. \" + (e && e.message) ? e.message : \"\"));\n            }\n            finally {\n                this.isDownloading = false;\n            }\n            const installFailed = yield NativeAppInfo.isFailedUpdate(this.packageHash);\n            const localPackage = new LocalPackage();\n            localPackage.deploymentKey = this.deploymentKey;\n            localPackage.description = this.description;\n            localPackage.label = this.label;\n            localPackage.appVersion = this.appVersion;\n            localPackage.isMandatory = this.isMandatory;\n            localPackage.packageHash = this.packageHash;\n            localPackage.isFirstRun = false;\n            localPackage.failedInstall = installFailed;\n            localPackage.localPath = file;\n            CodePushUtil.logMessage(\"Package download success: \" + JSON.stringify(localPackage));\n            Sdk.reportStatusDownload(localPackage, localPackage.deploymentKey);\n            return localPackage;\n        });\n    }\n    /**\n     * Aborts the current download session, previously started with download().\n     */\n    abortDownload() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: implement download abort\n            return new Promise((resolve) => {\n                this.isDownloading = false;\n                resolve();\n            });\n        });\n    }\n}\n//# sourceMappingURL=remotePackage.js.map","/**\n * Defines the possible result and intermediate statuses of the window.codePush.sync operation.\n * The result statuses are final, mutually exclusive statuses of the sync operation. The operation will end with only one of the possible result statuses.\n * The intermediate statuses are not final, one or more of them can happen before sync ends, based on the options you use and user interaction.\n *\n * NOTE: Adding new statuses or changing old statuses requires an update to CodePush.sync(), which must know which callbacks are results and which are not!\n *       Also, don't forget to change the TestMessage module in ServerUtils!\n *       AND THE codePush.d.ts (typings) file!!!\n */\nexport var SyncStatus;\n(function (SyncStatus) {\n    /**\n     * Result status - the application is up to date.\n     */\n    SyncStatus[SyncStatus[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    /**\n     * Result status - an update is available, it has been downloaded, unzipped and copied to the deployment folder.\n     * After the completion of the callback invoked with SyncStatus.UPDATE_INSTALLED, the application will be reloaded with the updated code and resources.\n     */\n    SyncStatus[SyncStatus[\"UPDATE_INSTALLED\"] = 1] = \"UPDATE_INSTALLED\";\n    /**\n     * Result status - an optional update is available, but the user declined to install it. The update was not downloaded.\n     */\n    SyncStatus[SyncStatus[\"UPDATE_IGNORED\"] = 2] = \"UPDATE_IGNORED\";\n    /**\n     * Result status - an error happened during the sync operation. This might be an error while communicating with the server, downloading or unziping the update.\n     * The console logs should contain more information about what happened. No update has been applied in this case.\n     */\n    SyncStatus[SyncStatus[\"ERROR\"] = 3] = \"ERROR\";\n    /**\n     * Result status - there is an ongoing sync in progress, so this attempt to sync has been aborted.\n     */\n    SyncStatus[SyncStatus[\"IN_PROGRESS\"] = 4] = \"IN_PROGRESS\";\n    /**\n     * Intermediate status - the plugin is about to check for updates.\n     */\n    SyncStatus[SyncStatus[\"CHECKING_FOR_UPDATE\"] = 5] = \"CHECKING_FOR_UPDATE\";\n    /**\n     * Intermediate status - a user dialog is about to be displayed. This status will be reported only if user interaction is enabled.\n     */\n    SyncStatus[SyncStatus[\"AWAITING_USER_ACTION\"] = 6] = \"AWAITING_USER_ACTION\";\n    /**\n     * Intermediate status - the update packages is about to be downloaded.\n     */\n    SyncStatus[SyncStatus[\"DOWNLOADING_PACKAGE\"] = 7] = \"DOWNLOADING_PACKAGE\";\n    /**\n     * Intermediate status - the update package is about to be installed.\n     */\n    SyncStatus[SyncStatus[\"INSTALLING_UPDATE\"] = 8] = \"INSTALLING_UPDATE\";\n})(SyncStatus || (SyncStatus = {}));\n//# sourceMappingURL=syncStatus.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Plugins } from \"@capacitor/core\";\nimport { AcquisitionStatus } from \"code-push/script/acquisition-sdk\";\nimport { CodePushUtil } from \"./codePushUtil\";\nimport InstallMode from \"./installMode\";\nimport { LocalPackage } from \"./localPackage\";\nimport { NativeAppInfo } from \"./nativeAppInfo\";\nimport { RemotePackage } from \"./remotePackage\";\nimport { Sdk } from \"./sdk\";\nimport { SyncStatus } from \"./syncStatus\";\nimport { Dialog } from \"@capacitor/dialog\";\nconst NativeCodePush = Plugins.CodePush;\n/**\n * This is the entry point to Cordova CodePush SDK.\n * It provides the following features to the app developer:\n * - polling the server for new versions of the app\n * - notifying the plugin that the application loaded successfully after an update\n * - getting information about the currently deployed package\n */\nexport class CodePush {\n    /**\n     * Notifies the plugin that the update operation succeeded and that the application is ready.\n     * Calling this function is required on the first run after an update. On every subsequent application run, calling this function is a noop.\n     * If using sync API, calling this function is not required since sync calls it internally.\n     */\n    notifyApplicationReady() {\n        return NativeCodePush.notifyApplicationReady();\n    }\n    /**\n     * Reloads the application. If there is a pending update package installed using ON_NEXT_RESTART or ON_NEXT_RESUME modes, the update\n     * will be immediately visible to the user. Otherwise, calling this function will simply reload the current version of the application.\n     */\n    restartApplication() {\n        return NativeCodePush.restartApplication();\n    }\n    /**\n     * Reports an application status back to the server.\n     * !!! This function is called from the native side, please make changes accordingly. !!!\n     */\n    reportStatus(status, label, appVersion, deploymentKey, previousLabelOrAppVersion, previousDeploymentKey) {\n        if (((!label && appVersion === previousLabelOrAppVersion) || label === previousLabelOrAppVersion)\n            && deploymentKey === previousDeploymentKey) {\n            // No-op since the new appVersion and label is exactly the same as the previous\n            // (the app might have been updated via a direct or HockeyApp deployment).\n            return;\n        }\n        var createPackageForReporting = (label, appVersion) => {\n            return {\n                /* The SDK only reports the label and appVersion.\n                   The rest of the properties are added for type safety. */\n                label, appVersion, deploymentKey,\n                description: null, isMandatory: false,\n                packageHash: null, packageSize: null,\n                failedInstall: false\n            };\n        };\n        var reportDone = (error) => {\n            var reportArgs = {\n                status,\n                label,\n                appVersion,\n                deploymentKey,\n                previousLabelOrAppVersion,\n                previousDeploymentKey\n            };\n            if (error) {\n                CodePushUtil.logError(`An error occurred while reporting status: ${JSON.stringify(reportArgs)}`, error);\n                NativeCodePush.reportFailed({ statusReport: reportArgs });\n            }\n            else {\n                CodePushUtil.logMessage(`Reported status: ${JSON.stringify(reportArgs)}`);\n                NativeCodePush.reportSucceeded({ statusReport: reportArgs });\n            }\n        };\n        switch (status) {\n            case ReportStatus.STORE_VERSION:\n                Sdk.reportStatusDeploy(null, AcquisitionStatus.DeploymentSucceeded, deploymentKey, previousLabelOrAppVersion, previousDeploymentKey, reportDone);\n                break;\n            case ReportStatus.UPDATE_CONFIRMED:\n                Sdk.reportStatusDeploy(createPackageForReporting(label, appVersion), AcquisitionStatus.DeploymentSucceeded, deploymentKey, previousLabelOrAppVersion, previousDeploymentKey, reportDone);\n                break;\n            case ReportStatus.UPDATE_ROLLED_BACK:\n                Sdk.reportStatusDeploy(createPackageForReporting(label, appVersion), AcquisitionStatus.DeploymentFailed, deploymentKey, previousLabelOrAppVersion, previousDeploymentKey, reportDone);\n                break;\n        }\n    }\n    /**\n     * Get the current package information.\n     *\n     * @returns The currently deployed package information.\n     */\n    getCurrentPackage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pendingUpdate = yield NativeAppInfo.isPendingUpdate();\n            var packageInfoFile = pendingUpdate ? LocalPackage.OldPackageInfoFile : LocalPackage.PackageInfoFile;\n            return new Promise((resolve, reject) => {\n                LocalPackage.getPackageInfoOrNull(packageInfoFile, resolve, reject);\n            });\n        });\n    }\n    /**\n     * Gets the pending package information, if any. A pending package is one that has been installed but the application still runs the old code.\n     * This happends only after a package has been installed using ON_NEXT_RESTART or ON_NEXT_RESUME mode, but the application was not restarted/resumed yet.\n     */\n    getPendingPackage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pendingUpdate = yield NativeAppInfo.isPendingUpdate();\n            if (!pendingUpdate)\n                return null;\n            return new Promise((resolve, reject) => {\n                LocalPackage.getPackageInfoOrNull(LocalPackage.PackageInfoFile, resolve, reject);\n            });\n        });\n    }\n    /**\n     * Checks with the CodePush server if an update package is available for download.\n     *\n     * @param querySuccess Callback invoked in case of a successful response from the server.\n     *                     The callback takes one RemotePackage parameter. A non-null package is a valid update.\n     *                     A null package means the application is up to date for the current native application version.\n     * @param queryError Optional callback invoked in case of an error.\n     * @param deploymentKey Optional deployment key that overrides the config.xml setting.\n     */\n    checkForUpdate(querySuccess, queryError, deploymentKey) {\n        try {\n            var callback = (error, remotePackageOrUpdateNotification) => __awaiter(this, void 0, void 0, function* () {\n                if (error) {\n                    CodePushUtil.invokeErrorCallback(error, queryError);\n                }\n                else {\n                    var appUpToDate = () => {\n                        CodePushUtil.logMessage(\"App is up to date.\");\n                        querySuccess && querySuccess(null);\n                    };\n                    if (remotePackageOrUpdateNotification) {\n                        if (remotePackageOrUpdateNotification.updateAppVersion) {\n                            /* There is an update available for a different version. In the current version of the plugin, we treat that as no update. */\n                            CodePushUtil.logMessage(\"An update is available, but it is targeting a newer binary version than you are currently running.\");\n                            appUpToDate();\n                        }\n                        else {\n                            /* There is an update available for the current version. */\n                            var remotePackage = remotePackageOrUpdateNotification;\n                            const installFailed = yield NativeAppInfo.isFailedUpdate(remotePackage.packageHash);\n                            var result = new RemotePackage();\n                            result.appVersion = remotePackage.appVersion;\n                            result.deploymentKey = deploymentKey; // server does not send back the deployment key\n                            result.description = remotePackage.description;\n                            result.downloadUrl = remotePackage.downloadUrl;\n                            result.isMandatory = remotePackage.isMandatory;\n                            result.label = remotePackage.label;\n                            result.packageHash = remotePackage.packageHash;\n                            result.packageSize = remotePackage.packageSize;\n                            result.failedInstall = installFailed;\n                            CodePushUtil.logMessage(\"An update is available. \" + JSON.stringify(result));\n                            querySuccess && querySuccess(result);\n                        }\n                    }\n                    else {\n                        appUpToDate();\n                    }\n                }\n            });\n            var queryUpdate = () => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const acquisitionManager = yield Sdk.getAcquisitionManager(deploymentKey);\n                    LocalPackage.getCurrentOrDefaultPackage().then((localPackage) => __awaiter(this, void 0, void 0, function* () {\n                        try {\n                            const currentBinaryVersion = yield NativeAppInfo.getApplicationVersion();\n                            localPackage.appVersion = currentBinaryVersion;\n                        }\n                        catch (e) {\n                        }\n                        CodePushUtil.logMessage(\"Checking for update.\");\n                        acquisitionManager.queryUpdateWithCurrentPackage(localPackage, callback);\n                    }), (error) => {\n                        CodePushUtil.invokeErrorCallback(error, queryError);\n                    });\n                }\n                catch (e) {\n                    CodePushUtil.invokeErrorCallback(e, queryError);\n                }\n            });\n            if (deploymentKey) {\n                queryUpdate();\n            }\n            else {\n                NativeAppInfo.getDeploymentKey().then(defaultDeploymentKey => {\n                    deploymentKey = defaultDeploymentKey;\n                    queryUpdate();\n                }, deploymentKeyError => {\n                    CodePushUtil.invokeErrorCallback(deploymentKeyError, queryError);\n                });\n            }\n        }\n        catch (e) {\n            CodePushUtil.invokeErrorCallback(new Error(\"An error occurred while querying for updates.\" + CodePushUtil.getErrorMessage(e)), queryError);\n        }\n    }\n    /**\n     * Convenience method for installing updates in one method call.\n     * This method is provided for simplicity, and its behavior can be replicated by using window.codePush.checkForUpdate(), RemotePackage's download() and LocalPackage's install() methods.\n     * If another sync is already running, it yields SyncStatus.IN_PROGRESS.\n     *\n     * The algorithm of this method is the following:\n     * - Checks for an update on the CodePush server.\n     * - If an update is available\n     *         - If the update is mandatory and the alertMessage is set in options, the user will be informed that the application will be updated to the latest version.\n     *           The update package will then be downloaded and applied.\n     *         - If the update is not mandatory and the confirmMessage is set in options, the user will be asked if they want to update to the latest version.\n     *           If they decline, the syncCallback will be invoked with SyncStatus.UPDATE_IGNORED.\n     *         - Otherwise, the update package will be downloaded and applied with no user interaction.\n     * - If no update is available on the server, the syncCallback will be invoked with the SyncStatus.UP_TO_DATE.\n     * - If an error occurs during checking for update, downloading or installing it, the syncCallback will be invoked with the SyncStatus.ERROR.\n     *\n     * @param syncCallback Optional callback to be called with the status of the sync operation.\n     *                     The callback will be called only once, and the possible statuses are defined by the SyncStatus enum.\n     * @param syncOptions Optional SyncOptions parameter configuring the behavior of the sync operation.\n     * @param downloadProgress Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n     * @param syncErrback Optional errback invoked if an error occurs. The callback will be called only once\n     *\n     */\n    sync(syncOptions, downloadProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /* Check if a sync is already in progress */\n            if (CodePush.SyncInProgress) {\n                /* A sync is already in progress */\n                CodePushUtil.logMessage(\"Sync already in progress.\");\n                return SyncStatus.IN_PROGRESS;\n            }\n            return new Promise((resolve, reject) => {\n                /* Create a callback that resets the SyncInProgress flag when the sync is complete\n                 * If the sync status is a result status, then the sync must be complete and the flag must be updated\n                 * Otherwise, do not change the flag and trigger the syncCallback as usual\n                 */\n                var syncCallbackAndUpdateSyncInProgress = (err, result) => {\n                    switch (result) {\n                        case SyncStatus.ERROR:\n                        case SyncStatus.IN_PROGRESS:\n                        case SyncStatus.UP_TO_DATE:\n                        case SyncStatus.UPDATE_IGNORED:\n                        case SyncStatus.UPDATE_INSTALLED:\n                            /* The sync has completed */\n                            CodePush.SyncInProgress = false;\n                            break;\n                        default:\n                            /* The sync is not yet complete, so do nothing */\n                            break;\n                    }\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(result);\n                };\n                /* Begin the sync */\n                CodePush.SyncInProgress = true;\n                this.syncInternal(syncCallbackAndUpdateSyncInProgress, syncOptions, downloadProgress);\n            });\n        });\n    }\n    /**\n     * Convenience method for installing updates in one method call.\n     * This method is provided for simplicity, and its behavior can be replicated by using window.codePush.checkForUpdate(), RemotePackage's download() and LocalPackage's install() methods.\n     *\n     * A helper function for the sync function. It does not check if another sync is ongoing.\n     *\n     * @param syncCallback Optional callback to be called with the status of the sync operation.\n     *                     The callback will be called only once, and the possible statuses are defined by the SyncStatus enum.\n     * @param syncOptions Optional SyncOptions parameter configuring the behavior of the sync operation.\n     * @param downloadProgress Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n     *\n     */\n    syncInternal(syncCallback, syncOptions, downloadProgress) {\n        /* No options were specified, use default */\n        if (!syncOptions) {\n            syncOptions = this.getDefaultSyncOptions();\n        }\n        else {\n            /* Some options were specified */\n            /* Handle dialog options */\n            var defaultDialogOptions = this.getDefaultUpdateDialogOptions();\n            if (syncOptions.updateDialog) {\n                if (typeof syncOptions.updateDialog !== typeof ({})) {\n                    /* updateDialog set to truey condition, use default options */\n                    syncOptions.updateDialog = defaultDialogOptions;\n                }\n                else {\n                    /* some options were specified, merge with default */\n                    CodePushUtil.copyUnassignedMembers(defaultDialogOptions, syncOptions.updateDialog);\n                }\n            }\n            /* Handle other options. Dialog options will not be overwritten. */\n            var defaultOptions = this.getDefaultSyncOptions();\n            CodePushUtil.copyUnassignedMembers(defaultOptions, syncOptions);\n        }\n        this.notifyApplicationReady();\n        var onError = (error) => {\n            CodePushUtil.logError(\"An error occurred during sync.\", error);\n            syncCallback && syncCallback(error, SyncStatus.ERROR);\n        };\n        var onInstallSuccess = (appliedWhen) => {\n            switch (appliedWhen) {\n                case InstallMode.ON_NEXT_RESTART:\n                    CodePushUtil.logMessage(\"Update is installed and will be run on the next app restart.\");\n                    break;\n                case InstallMode.ON_NEXT_RESUME:\n                    if (syncOptions.minimumBackgroundDuration > 0) {\n                        CodePushUtil.logMessage(`Update is installed and will be run after the app has been in the background for at least ${syncOptions.minimumBackgroundDuration} seconds.`);\n                    }\n                    else {\n                        CodePushUtil.logMessage(\"Update is installed and will be run when the app next resumes.\");\n                    }\n                    break;\n            }\n            syncCallback && syncCallback(null, SyncStatus.UPDATE_INSTALLED);\n        };\n        var onDownloadSuccess = (localPackage) => {\n            syncCallback && syncCallback(null, SyncStatus.INSTALLING_UPDATE);\n            localPackage.install(syncOptions).then(onInstallSuccess, onError);\n        };\n        var downloadAndInstallUpdate = (remotePackage) => {\n            syncCallback && syncCallback(null, SyncStatus.DOWNLOADING_PACKAGE);\n            remotePackage.download(downloadProgress).then(onDownloadSuccess, onError);\n        };\n        var onUpdate = (remotePackage) => __awaiter(this, void 0, void 0, function* () {\n            var updateShouldBeIgnored = remotePackage && (remotePackage.failedInstall && syncOptions.ignoreFailedUpdates);\n            if (!remotePackage || updateShouldBeIgnored) {\n                if (updateShouldBeIgnored) {\n                    CodePushUtil.logMessage(\"An update is available, but it is being ignored due to have been previously rolled back.\");\n                }\n                syncCallback && syncCallback(null, SyncStatus.UP_TO_DATE);\n            }\n            else {\n                var dlgOpts = syncOptions.updateDialog;\n                if (dlgOpts) {\n                    CodePushUtil.logMessage(\"Awaiting user action.\");\n                    syncCallback && syncCallback(null, SyncStatus.AWAITING_USER_ACTION);\n                }\n                if (remotePackage.isMandatory && syncOptions.updateDialog) {\n                    /* Alert user */\n                    var message = dlgOpts.appendReleaseDescription ?\n                        dlgOpts.mandatoryUpdateMessage + dlgOpts.descriptionPrefix + remotePackage.description\n                        : dlgOpts.mandatoryUpdateMessage;\n                    yield Dialog.alert({\n                        message,\n                        title: dlgOpts.updateTitle,\n                        buttonTitle: dlgOpts.mandatoryContinueButtonLabel\n                    });\n                    downloadAndInstallUpdate(remotePackage);\n                }\n                else if (!remotePackage.isMandatory && syncOptions.updateDialog) {\n                    /* Confirm update with user */\n                    var message = dlgOpts.appendReleaseDescription ?\n                        dlgOpts.optionalUpdateMessage + dlgOpts.descriptionPrefix + remotePackage.description\n                        : dlgOpts.optionalUpdateMessage;\n                    const confirmResult = yield Dialog.confirm({\n                        message,\n                        title: dlgOpts.updateTitle,\n                        okButtonTitle: dlgOpts.optionalInstallButtonLabel,\n                        cancelButtonTitle: dlgOpts.optionalIgnoreButtonLabel\n                    });\n                    if (confirmResult.value) {\n                        /* Install */\n                        downloadAndInstallUpdate(remotePackage);\n                    }\n                    else {\n                        /* Cancel */\n                        CodePushUtil.logMessage(\"User cancelled the update.\");\n                        syncCallback && syncCallback(null, SyncStatus.UPDATE_IGNORED);\n                    }\n                }\n                else {\n                    /* No user interaction */\n                    downloadAndInstallUpdate(remotePackage);\n                }\n            }\n        });\n        syncCallback && syncCallback(null, SyncStatus.CHECKING_FOR_UPDATE);\n        this.checkForUpdate(onUpdate, onError, syncOptions.deploymentKey);\n    }\n    /**\n     * Returns the default options for the CodePush sync operation.\n     * If the options are not defined yet, the static DefaultSyncOptions member will be instantiated.\n     */\n    getDefaultSyncOptions() {\n        if (!CodePush.DefaultSyncOptions) {\n            CodePush.DefaultSyncOptions = {\n                ignoreFailedUpdates: true,\n                installMode: InstallMode.ON_NEXT_RESTART,\n                minimumBackgroundDuration: 0,\n                mandatoryInstallMode: InstallMode.IMMEDIATE,\n                updateDialog: false,\n                deploymentKey: undefined\n            };\n        }\n        return CodePush.DefaultSyncOptions;\n    }\n    /**\n     * Returns the default options for the update dialog.\n     * Please note that the dialog is disabled by default.\n     */\n    getDefaultUpdateDialogOptions() {\n        if (!CodePush.DefaultUpdateDialogOptions) {\n            CodePush.DefaultUpdateDialogOptions = {\n                updateTitle: \"Update available\",\n                mandatoryUpdateMessage: \"An update is available that must be installed.\",\n                mandatoryContinueButtonLabel: \"Continue\",\n                optionalUpdateMessage: \"An update is available. Would you like to install it?\",\n                optionalInstallButtonLabel: \"Install\",\n                optionalIgnoreButtonLabel: \"Ignore\",\n                appendReleaseDescription: false,\n                descriptionPrefix: \" Description: \"\n            };\n        }\n        return CodePush.DefaultUpdateDialogOptions;\n    }\n}\n/**\n * Defines the application statuses reported from the native layer.\n * !!! This enum is defined in native code as well, please make changes accordingly. !!!\n */\nvar ReportStatus;\n(function (ReportStatus) {\n    ReportStatus[ReportStatus[\"STORE_VERSION\"] = 0] = \"STORE_VERSION\";\n    ReportStatus[ReportStatus[\"UPDATE_CONFIRMED\"] = 1] = \"UPDATE_CONFIRMED\";\n    ReportStatus[ReportStatus[\"UPDATE_ROLLED_BACK\"] = 2] = \"UPDATE_ROLLED_BACK\";\n})(ReportStatus || (ReportStatus = {}));\n//# sourceMappingURL=codePush.js.map"],"names":["this","Plugins"],"mappings":"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"}